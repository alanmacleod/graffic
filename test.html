

<html>
<head>
  <style>
    #display {
      border: 1px solid gray;
      width: 640px;
      height: 480px;
    }
  </style>
</head>
<body>

<canvas id="display" width="640" height="480"/>


</body>

</html>

<script>

const Vector2 = {
  add: function(a, b)
  {
    return [
      a[0] + b[0],
      a[1] + b[1]
    ]
  },
  sub: function(a, b)
  {
    return [
      a[0] - b[0],
      a[1] - b[1]
    ];
  },
  norm: function(v)
  {
    let m = this.mag( v );
    return m===0 ? [0,0] : [v[0]/m, v[1]/m];
  },
  mag: function(v)
  {
    return Math.sqrt(v[0] * v[0] + v[1]*v[1]);
  }
}

let scene = [];
let c = document.getElementById("display");
let ctx = c.getContext('2d');

console.log(
  Vector2.sub([100, 100], [10, 10])
);

let obj = gen_square(100, 100, 100);
let obj2 = gen_square(195, 199, 50);

let start = [10, 10];
let end = [250, 250];

let line =[[100,150], [300,200]];
let normal = get_unit_normal(line);
let perp = get_perpendicular(line, normal, 10);

draw_line(line[0], line[1], 'red');
draw_line(perp[0], perp[1], 'blue');


scene.push(obj);

// draw_scene(scene, start, end);
// calc_scene_graph(scene, start, end);

function get_perpendicular(line, normal, size)
{
  let mx = (line[0][0] + line[1][0]) / 2;
  let my = (line[0][1] + line[1][1]) / 2;
  return [
    [mx, my],
    [mx + (normal[0] * size), my + (normal[1] * size)]
  ];
}


function get_unit_normal(l)
{
  const X=0, Y=1;
  let dx = l[1][X] - l[0][X];
  let dy = l[1][Y] - l[0][Y];

  let n = translate_to([[-dy, dx], [dy, -dx]], [0,0]);
  let m = len([0,0], n[1]);

  return m !==0 ? [n[1][0] / m, n[1][1] / m] : undefined;
}

function translate_to(l, o)
{
  let xd = o[0] - l[0][0];
  let yd = o[1] - l[0][1];
  return [
    [l[0][0] + xd, l[0][1] + yd],
    [l[1][0] + xd, l[1][1] + yd]
  ];
}


function calc_scene_graph(obstacles, start, end)
{
  // 1. keep a list of geometry (obstacles)
  // 2. extract nodes

  // a list of unique points/vertices in the scene
  let nodes = [];

  // an edge is a a line joined by two vertices. the vertex of each edge
  // can be duplicated, e.g. might share a vertex with the next edge
  let edges = [];

  // add our start and endpoints to the graph
  nodes.push(start);
  nodes.push(end);

  //now every vertex in all obstacle geometry

  for (let o of obstacles)
  {
    // extract each obstacle's edges and nodes
    let e;
    for (e=0; e<o.length-1; e++)
    {
      edges.push([o[e], o[e+1]]);
      nodes.push(o[e]);
    }

    // this isn't a closed ring (matching start and endp)
    if (!equals(o[0], o[e]))
      nodes.push(o[e])
  }

  // now, test each node against all other nodes
  // if a direct line-of-sight, create a 'GraphEdge'

  // This nested iteration allows us to test each line only
  // once. i.e. testing A -> B and not B -> A, which would be redundant
  // To help visualise this, draw out the 2d table on paper
  // you'll see the diagonal (X==Y) is obv skipped. Everything above the
  // diagonal is tested, everything below is, ofc, a mirror of above.

  for (let x=0; x<nodes.length-1; x++)
    for (let y=x+1; y<nodes.length; y++)
    {
        let testedge = [nodes[x], nodes[y]];

        // yes, this is a clear path, draw it now
        // Need to test for incursion into null space
        // if (edgevisibilty(testedge, edges))

        {
          //console.log("ok!")
          draw_line(testedge[0], testedge[1], 'magenta');
        }

    }

  for (let e=0; e<edges.length; e++)
  {
    //console.log(edges[e]);
    // draw_line(edges[e][0], edges[e][1], 'magenta');

  }
}

function len(a, b)
{
  let dx = b[0] - a[0] // x2 - x1
  let dy = b[1] - a[1];
  return Math.sqrt( dx*dx + dy*dy );

}

function edgevisibilty(testedge, edges)
{
  for (let t=0; t<edges.length; t++)
  {
    let e = edges[t];

    if (intersects(
      testedge[0][0], testedge[0][1],
      testedge[1][0], testedge[1][1],
      e[0][0], e[0][1],
      e[1][0], e[1][1],
    ))
      return false;
  }

  return true;
}

function equals(a, b)
{
  return (a[0] == b[0] && a[1] == b[1]);
}

function draw_scene(scene, startp, endp)
{
  let drawnstart = false;

  // Draw all obstacles
  for (let o of scene)
  {
    if (Array.isArray(o[0]))
    {
      for (let e=0; e<o.length-1; e++)
        draw_line(o[e], o[e+1], 'black');
    }
  }

  // Draw circles for start + end
  if (startp && endp)
  {
    ctx.beginPath();
    ctx.arc(startp[0], startp[1], 5, 0, 2 * Math.PI, false);
    ctx.fillStyle = 'green';
    ctx.fill();

    ctx.beginPath();
    ctx.arc(endp[0], endp[1], 5, 0, 2 * Math.PI, false);
    ctx.fillStyle = 'red';
    ctx.fill();
  }

}

function draw_line(a, b, c)
{
  ctx.lineWidth = 2;
  ctx.strokeStyle = c || 'black';
  ctx.beginPath();
  ctx.moveTo(a[0],a[1]);
  ctx.lineTo(b[0],b[1]);
  ctx.stroke();
}

function intersects(a,b,c,d,  p,q,r,s)
{
  var det, gamma, lambda;
  det = (c - a) * (s - q) - (r - p) * (d - b);
  if (det === 0) {
    return false;
  } else {

    lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
    gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
    return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);
  }
}


function gen_square(x, y, size)
{
  let hsize = size>>1;
  let sq = [];
  // or just make a unit square and scale it up duh :|
  // top left
  sq.push( [x - hsize, y - hsize] );
  // top right
  sq.push( [x + hsize, y - hsize] );
  // bottom right
  sq.push( [x + hsize, y + hsize] );
  // bottom left
  sq.push( [x - hsize, y + hsize] );
  // top left again
  sq.push( [x - hsize, y - hsize] );

  return sq;
}




//
//
// function Vector2(x, y)
// {
//   this.x = x || 0;
//   this.y = y || 0;
//
//   this.set = function(x, y)
//   {
//     [this.x, this.y] = [x, y];
//     return this;
//   }
//
//   // Create new vectors
//
//   this.sub = function(b)
//   {
//     return new Vector2(this.x - b.x, this.y - b.y);
//   }
//
//   this.add = function(b)
//   {
//     return new Vector2(b.x + this.x, b.y + this.y);
//   }
//
//   this.mul = function(s)
//   {
//     return new Vector2(this.x * s, this.y * s);
//   }
//
//
//   this.div = function(s)
//   {
//     return new Vector2(this.x / s, this.y / s);
//   }
//
//   // Arithmetic in-place
//
//   this.tsub = function(b)
//   {
//     this.x -= b.x;
//     this.y -= b.y;
//     return this;
//   }
//
//   this.tadd = function(b)
//   {
//     this.x += b.x;
//     this.y += b.y;
//     return this;
//   }
//
//   this.tmul = function(s)
//   {
//     this.x *= s;
//     this.y *= s;
//     return this;
//   }
//
//   this.tdiv = function(s)
//   {
//     this.x /= s;
//     this.y /= s;
//     return this;
//   }
//
//   this.tnorm = function()
//   {
//     let m = this.mag();
//     return m ? this.tdiv(m) : this;
//   }
//
//   this.norm = function()
//   {
//     let m = this.mag();
//     return m ? this.div(m) : new Vector2(this.x, this.y);
//   }
//
//   this.mag = function()
//   {
//     return Math.sqrt(this.x * this.x + this.y * this.y);
//   }
//
//   this.dist = function(b)
//   {
//     let [xd, yd] = [ b.x - this.x, b.y - this.y];
//     return Math.sqrt(xd*xd + yd*yd);
//   }
//
//   this.distsq = function(b)
//   {
//     let [xd, yd] = [ b.x - this.x, b.y - this.y];
//     return (xd*xd + yd*yd);
//   }
//
// }


</script>
