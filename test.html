

<html>
<head>
  <style>
    #display {
      border: 1px solid gray;
      width: 640px;
      height: 480px;
    }
  </style>
</head>
<script src='./line-segments-intersect.js'></script>

<body>

<canvas id="display" width="640" height="480"/>

</body>

</html>

<script>

// let linea = [[10,10], [300, 300]];
// let lineb = [[150, 10], [50, 150]];
//
// let res = doLineSegmentsIntersect(linea[0], linea[1], lineb[0], lineb[1]);
//
// console.log(`Intersection test says: ${res}`);


console.log("****");

let endpoint_kiss = [[10, 10], [100,100], [100, 100], [100, 200]];
let coplanar_endpoint_join_overlap = [[10, 10], [10, 200], [10, 10], [10, 100]];
let coplanar_endpoint_kiss = [[10, 10], [10, 100], [10, 100], [10, 200]];

// passthrough rect's corner test
let midpoint_touch = [[10, 10], [200,200], [100, 100], [100, 200]];

let cs = endpoint_kiss;

let res = intersects(cs[0], cs[1], cs[2], cs[3]);

console.log("Intersect2 = ", res);

console.log("****");


let scene = [];
let c = document.getElementById("display");
let ctx = c.getContext('2d');

// console.log(
//   Vector2.sub([100, 100], [10, 10])
// );

//


let obj = gen_square(100, 100, 100);

// let obj = [[10, 300], [300, 10]];

let start = [10, 10];
let end = [300, 300];

// let res = edgevisibilty([start, end], [obj]);
//
// console.log(res);
//
// for (var t=0; t<obj.length; t++)
// {
//   let a = t;
//   let b = (t+1) % obj.length;
//
//   var tline = [obj[a], obj[b]];
//
//   let r = edgevisibilty([start, end], [tline]);
//
//   console.log(r);
// }



// let start = [10, 100];
// let end = [250, 100];

// let line =[[120,50], [120,200]];
// draw_line(line[0], line[1], 'black');

// console.log(obj);
// let r = edgevisibilty([start, end], [line])
// console.log(r);

// let pt = [200, 400];
// let normal = get_unit_normal(line);
// let perp = get_perpendicular(line, normal, 10);

// // 2d plane
// draw_line(line[0], line[1], 'red');
//
// // 2d point
// ctx.beginPath();
// ctx.arc(pt[0], pt[1], 5, 0, 2 * Math.PI, false);
// ctx.fillStyle = 'blue';
// ctx.fill();

// let d = ((pt[0] - line[0][0]) * (line[1][1] - line[0][1])) - ((pt[1] - line[0][1]) * (line[1][0] - line[0][0]));


// console.log("d = " + d);

// draw_line(perp[0], perp[1], 'blue');

scene.push(obj);
//
draw_scene(scene, start, end);
calc_scene_graph(scene, start, end);
//

function calc_scene_graph(obstacles, start, end)
{
  // 1. keep a list of geometry (obstacles)
  // 2. extract nodes

  // a list of unique points/vertices in the scene
  let nodes = [];

  // an edge is a line joined by two vertices. the vertex of each edge
  // can be duplicated, e.g. might share a vertex with the next edge

  // Edges are solid and are iterated to test the visibility of one point (node)
  // to another

  let edges = [];

  let shape_id = 1;

  // add our start and endpoints to the graph
  nodes.push( {vertex: start,  shape: shape_id++} );
  nodes.push( {vertex: end,    shape: shape_id++} );

  //now every vertex in all obstacle geometry

  for (let o of obstacles)
  {
    // extract each obstacle's edges and nodes

    shape_id++;

    let e;
    for (e=0; e<o.length-1; e++)
    {
      edges.push([o[e], o[e+1]]);
      //console.log("node: ", o[e])
      nodes.push({
        vertex: o[e],
        shape: shape_id
      });
      //nodes.push({o[e]);
    }

    // this isn't a closed ring (matching start and endp)
    if (!equals(o[0], o[e]))
      nodes.push({
        vertex: o[e],
        shape: shape_id
      });
  }

  // now, test each node against all other nodes
  // if a direct line-of-sight, create a 'GraphEdge'

  // This nested iteration allows us to test each line only
  // once. i.e. testing A -> B and not B -> A, which would be redundant
  // To help visualise this, draw out the 2d table on paper
  // you'll see the diagonal (X==Y) is obv skipped. Everything above the
  // diagonal is tested, everything below is, ofc, a mirror of above.

  for (let x=0; x<nodes.length-1; x++)
    for (let y=x+1; y<nodes.length; y++)
    {
        let A = nodes[x];
        let B = nodes[y];

        // We're testing the shape's vertices against itself
        // which leads to internal paths inside the shape (invalid!)
        if (A.shape == B.shape) continue;

        let testedge = [A.vertex, B.vertex];

        console.log(A, B);

        // yes, this is a clear path, draw it now
        // Need to test for incursion into null space
        if (edgevisibilty(testedge, edges))
        {
          //console.log("ok!")
          draw_line(testedge[0], testedge[1], 'magenta');
        } else {
          console.log("not visible")
        }

    }

  for (let e=0; e<edges.length; e++)
  {
    //console.log(edges[e]);
    // draw_line(edges[e][0], edges[e][1], 'magenta');

  }
}

function len(a, b)
{
  let dx = b[0] - a[0] // x2 - x1
  let dy = b[1] - a[1];
  return Math.sqrt( dx*dx + dy*dy );

}

function edgevisibilty(testedge, edges)
{
  console.log(`Testing edge: ${testedge[0]}, ${testedge[1]}`);

  for (let t=0; t<edges.length; t++)
  {
    let e = edges[t];

    let res = intersects(testedge[0], testedge[1], e[0], e[1]);

    // If intersection, check it's not just the endpoints touching which is ok
    // console.log(`Intersecting: (${testedge[0]}, ${testedge[1]}) -> (${e[0]}, ${e[1]}) == ${res}`);

    if (res.intersect && !res.kiss)
      return false;

  }

  return true;
}

function equals(a, b)
{
  return (a[0] == b[0] && a[1] == b[1]);
}

function draw_scene(scene, startp, endp)
{
  let drawnstart = false;

  // Draw all obstacles
  for (let o of scene)
  {
    if (Array.isArray(o[0]))
    {
      for (let e=0; e<o.length-1; e++)
        draw_line(o[e], o[e+1], 'black');
    }
  }

  // Draw circles for start + end
  if (startp && endp)
  {
    ctx.beginPath();
    ctx.arc(startp[0], startp[1], 5, 0, 2 * Math.PI, false);
    ctx.fillStyle = 'green';
    ctx.fill();

    ctx.beginPath();
    ctx.arc(endp[0], endp[1], 5, 0, 2 * Math.PI, false);
    ctx.fillStyle = 'red';
    ctx.fill();
  }

}

function draw_line(a, b, c)
{
  ctx.lineWidth = 2;
  ctx.strokeStyle = c || 'black';
  ctx.beginPath();
  ctx.moveTo(a[0],a[1]);
  ctx.lineTo(b[0],b[1]);
  ctx.stroke();
}

function intersects_old_doesnt_work_properly_100pc(a,b,c,d,  p,q,r,s)
{
  var det, gamma, lambda;
  det = (c - a) * (s - q) - (r - p) * (d - b);

  // console.log(`intesects.det = ${det}`);
  if (det === 0) {
    return false;
  } else {

    lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
    gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;

    // console.log(`intesects.lambda/gamma = ${lambda},${gamma}`);
    return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);
  }
}


function gen_square(x, y, size)
{
  let hsize = size>>1;
  let sq = [];
  // or just make a unit square and scale it up duh :|
  // top left
  sq.push( [x - hsize, y - hsize] );
  // top right
  sq.push( [x + hsize, y - hsize] );
  // bottom right
  sq.push( [x + hsize, y + hsize] );
  // bottom left
  sq.push( [x - hsize, y + hsize] );
  // top left again
  sq.push( [x - hsize, y - hsize] );

  return sq;
}


function get_perpendicular(line, normal, size)
{
  let mx = (line[0][0] + line[1][0]) / 2;
  let my = (line[0][1] + line[1][1]) / 2;
  return [
    [mx, my],
    [mx + (normal[0] * size), my + (normal[1] * size)]
  ];
}


function get_unit_normal(l)
{
  const X=0, Y=1;
  let dx = l[1][X] - l[0][X];
  let dy = l[1][Y] - l[0][Y];

  let n = translate_to([[-dy, dx], [dy, -dx]], [0,0]);
  let m = len([0,0], n[1]);

  return m !==0 ? [n[1][0] / m, n[1][1] / m] : undefined;
}

function translate_to(l, o)
{
  let xd = o[0] - l[0][0];
  let yd = o[1] - l[0][1];
  return [
    [l[0][0] + xd, l[0][1] + yd],
    [l[1][0] + xd, l[1][1] + yd]
  ];
}


//
//
// function Vector2(x, y)
// {
//   this.x = x || 0;
//   this.y = y || 0;
//
//   this.set = function(x, y)
//   {
//     [this.x, this.y] = [x, y];
//     return this;
//   }
//
//   // Create new vectors
//
//   this.sub = function(b)
//   {
//     return new Vector2(this.x - b.x, this.y - b.y);
//   }
//
//   this.add = function(b)
//   {
//     return new Vector2(b.x + this.x, b.y + this.y);
//   }
//
//   this.mul = function(s)
//   {
//     return new Vector2(this.x * s, this.y * s);
//   }
//
//
//   this.div = function(s)
//   {
//     return new Vector2(this.x / s, this.y / s);
//   }
//
//   // Arithmetic in-place
//
//   this.tsub = function(b)
//   {
//     this.x -= b.x;
//     this.y -= b.y;
//     return this;
//   }
//
//   this.tadd = function(b)
//   {
//     this.x += b.x;
//     this.y += b.y;
//     return this;
//   }
//
//   this.tmul = function(s)
//   {
//     this.x *= s;
//     this.y *= s;
//     return this;
//   }
//
//   this.tdiv = function(s)
//   {
//     this.x /= s;
//     this.y /= s;
//     return this;
//   }
//
//   this.tnorm = function()
//   {
//     let m = this.mag();
//     return m ? this.tdiv(m) : this;
//   }
//
//   this.norm = function()
//   {
//     let m = this.mag();
//     return m ? this.div(m) : new Vector2(this.x, this.y);
//   }
//
//   this.mag = function()
//   {
//     return Math.sqrt(this.x * this.x + this.y * this.y);
//   }
//
//   this.dist = function(b)
//   {
//     let [xd, yd] = [ b.x - this.x, b.y - this.y];
//     return Math.sqrt(xd*xd + yd*yd);
//   }
//
//   this.distsq = function(b)
//   {
//     let [xd, yd] = [ b.x - this.x, b.y - this.y];
//     return (xd*xd + yd*yd);
//   }
//
// }


</script>
