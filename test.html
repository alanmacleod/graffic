

<html>
<head>
  <style>
    #display {
      border: 1px solid gray;
      width: 640px;
      height: 480px;
    }
  </style>
</head>
<body>

<canvas id="display" width="640" height="480"/>


</body>

</html>

<script>

let scene = [];
let c = document.getElementById("display");
let ctx = c.getContext('2d');

let obj = gen_square(100, 100, 100);
let obj2 = gen_square(200, 200, 50);

let start = [10, 10];
let end = [250, 250];

scene.push(obj);
// scene.push(obj2);

draw_scene(scene, start, end);

calc_scene_graph(scene, start, end);

function calc_scene_graph(obstacles, start, end)
{
  // 1. keep a list of geometry (obstacles)
  // 2. extract nodes

  // a list of unique points/vertices in the scene
  let nodes = [];

  // an edge is a a line joined by two vertices. the vertex of each edge
  // can be duplicated, e.g. might share a vertex with the next edge
  let edges = [];

  // add our start and endpoints to the graph
  nodes.push(start);
  nodes.push(end);

  //now every vertex in all obstacle geometry

  for (let o of obstacles)
  {
    // extract each obstacle's edges and nodes
    let e;
    for (e=0; e<o.length-1; e++)
    {
      edges.push([o[e], o[e+1]]);
      nodes.push(o[e]);
    }

    // this isn't a closed ring (matching start and endp)
    if (!equals(o[0], o[e]))
      nodes.push(o[e])
  }

  // now, test each node against all other nodes
  // if a direct line-of-sight, create a 'GraphEdge'

  // This nested iteration allows us to test each line only
  // once. i.e. testing A -> B and not B -> A, which would be redundant
  // To help visualise this, draw out the 2d table on paper
  // you'll see the diagonal (X==Y) is obv skipped. Everything above the
  // diagonal is tested, everything below is, ofc, a mirror of above.

  for (let x=0; x<nodes.length-1; x++)
    for (let y=x+1; y<nodes.length; y++)
    {
        let testedge = [nodes[x], nodes[y]];

        // yes, this is a clear path, draw it now
        // Need to test for incursion into null space
        // if (edgevisibilty(testedge, edges))
        
        {
          //console.log("ok!")
          draw_line(testedge[0], testedge[1], 'magenta');
        }

    }

  for (let e=0; e<edges.length; e++)
  {
    //console.log(edges[e]);
    // draw_line(edges[e][0], edges[e][1], 'magenta');

  }
}

function edgevisibilty(testedge, edges)
{
  for (let t=0; t<edges.length; t++)
  {
    let e = edges[t];

    if (intersects(
      testedge[0][0], testedge[0][1],
      testedge[1][0], testedge[1][1],
      e[0][0], e[0][1],
      e[1][0], e[1][1],
    ))
      return false;
  }

  return true;
}

function equals(a, b)
{
  return (a[0] == b[0] && a[1] == b[1]);
}

function draw_scene(scene, startp, endp)
{
  let drawnstart = false;

  // Draw all obstacles
  for (let o of scene)
  {
    if (Array.isArray(o[0]))
    {
      for (let e=0; e<o.length-1; e++)
        draw_line(o[e], o[e+1], 'black');
    }
  }

  // Draw circles for start + end
  if (startp && endp)
  {
    ctx.beginPath();
    ctx.arc(startp[0], startp[1], 5, 0, 2 * Math.PI, false);
    ctx.fillStyle = 'green';
    ctx.fill();

    ctx.beginPath();
    ctx.arc(endp[0], endp[1], 5, 0, 2 * Math.PI, false);
    ctx.fillStyle = 'red';
    ctx.fill();
  }

}

function draw_line(a, b, c)
{
  ctx.lineWidth = 2;
  ctx.strokeStyle = c || 'black';
  ctx.beginPath();
  ctx.moveTo(a[0],a[1]);
  ctx.lineTo(b[0],b[1]);
  ctx.stroke();
}

function intersects(a,b,c,d,  p,q,r,s)
{
  var det, gamma, lambda;
  det = (c - a) * (s - q) - (r - p) * (d - b);
  if (det === 0) {
    return false;
  } else {

    lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
    gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
    return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);
  }
}


function gen_square(x, y, size)
{
  let hsize = size>>1;
  let sq = [];

  // or just make a unit square and scale it up duh :|

  // top left
  sq.push( [x - hsize, y - hsize] );
  // top right
  sq.push( [x + hsize, y - hsize] );
  // bottom right
  sq.push( [x + hsize, y + hsize] );
  // bottom left
  sq.push( [x - hsize, y + hsize] );
  // top left again
  sq.push( [x - hsize, y - hsize] );

  return sq;
}


</script>
